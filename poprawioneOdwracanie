package pg.eti.kams.bioinffilogeneza2013;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Vector;
import org.jblas.DoubleMatrix;
import org.jblas.MatrixFunctions;
import org.jblas.Solve;

/**
 * Hello world!
 *
 */

/*
 * DFS
 *
 * enum VertexState { White, Gray, Black }
 *
 * public void DFS() { VertexState state[] = new VertexState[vertexCount]; for
 * (int i = 0; i < vertexCount; i++) state[i] = VertexState.White; runDFS(0,
 * state); }
 *
 * public void runDFS(int u, VertexState[] state) { state[u] = VertexState.Gray;
 * for (int v = 0; v < vertexCount; v++) if (isEdge(u, v) && state[v] ==
 * VertexState.White) runDFS(v, state); state[u] = VertexState.Black; }
 *
 */
//http://www.codeproject.com/Articles/405128/Matrix-operations-in-Java
public class Main {



    public enum VertexState {

        White, Gray, Black
    }
    public static void wypisz(DoubleMatrix p)
    {
        System.out.print("[");
        for (int i = 0; i < p.rows; i++) {
            for (int j = 0; j < p.columns; j++) {
                System.out.print(p.get(i,j) + "\t");
            }
            if(i!=p.columns-1)
                System.out.println("");
            else System.out.println("]");
        }
    }
    
    public static DoubleMatrix transpose(DoubleMatrix matrix) {
        DoubleMatrix transposedMatrix = new DoubleMatrix(matrix.getColumns(), matrix.getRows());
        for (int i=0;i<matrix.getRows();i++) {
            for (int j=0;j<matrix.getColumns();j++) {
                transposedMatrix.put(j, i, matrix.get(i, j));
            }
        }
        return transposedMatrix;
    }
    
    public static double determinant(DoubleMatrix matrix)  {

        if (matrix.getColumns()==2) {//sprawdzanie czy size to 2
            return (matrix.get(0, 0) * matrix.get(1, 1)) - ( matrix.get(0, 1) * matrix.get(1, 0));
        }
        double sum = 0.0;
        for (int i=0; i<matrix.getColumns(); i++) {
            sum += changeSign(i) * matrix.get(0, i) * determinant(createSubMatrix(matrix, 0, i));
        }
        return sum;
    }
    
    private static double changeSign(int i) {
        if(i%2==0)
            return 1;
        return -1;
    }
    
    public static DoubleMatrix createSubMatrix(DoubleMatrix matrix, int excluding_row, int excluding_col) {
        DoubleMatrix mat = new DoubleMatrix(matrix.getRows()-1, matrix.getColumns()-1);
        int r = -1;
        for (int i=0;i<matrix.getRows();i++) {
            if (i==excluding_row)
                continue;
                r++;
                int c = -1;
            for (int j=0;j<matrix.getColumns();j++) {
                if (j==excluding_col)
                    continue;
                mat.put(r, ++c, matrix.get(i,j));//getValueAt(i, j)
            }
        }
        return mat;
    } 
    
    public static DoubleMatrix cofactor(DoubleMatrix matrix) 
    {
        DoubleMatrix mat = new DoubleMatrix(matrix.getRows(),matrix.getColumns());
        for (int i=0;i<matrix.getRows();i++) {
            for (int j=0; j<matrix.getColumns();j++) {
                mat.put(i, j, changeSign(i) * changeSign(j) * determinant(createSubMatrix(matrix, i, j)));
            }
        }

        return mat;
    }
    
    /**
     *
     * @param matrix
     * @return
     */
    public static DoubleMatrix ownInverse(DoubleMatrix matrix)
    {
        return (transpose(cofactor(matrix)).mul((1.0/determinant(matrix))));//matrix) multiplyByConstant
    }
    
    /*public static DoubleMatrix odwracaczMacierzy(DoubleMatrix m)
    {
        //
        for (int i = 0; i < m.rows; i++) {
            for (int j = 0; j < m.columns; j++) {
                //wykreślamy i-ty wiersz i j-tą kolumnę
                DoubleMatrix newM = new DoubleMatrix(m.rows-1, m.columns-1);
                int newRow = 0;
                int newColumn = 0;
                for (int k = 0; k < m.rows; k++) 
                {
                    for (int l = 0; l < m.columns; l++) 
                    {
                        if(k!=i || l!=j)
                        {
                            newM.put(k,l);
                        }
                    }
                }
                System.out.println("Mamy:");
                wypisz(newM);
            }
            if(i!=p.columns-1)
                System.out.println("");
            else System.out.println("]");
        }
        return m;
    }*/
    
    public static void DFS(DoubleMatrix A, DoubleMatrix d, DoubleMatrix g, ArrayList[] V, int vertNum) {
        int krawedzie = 0;
        for (int i = 0; i <= vertNum; i++) {
            krawedzie += V[i].size();
        }

        krawedzie /= 2;
        //System.out.println("A wymiar: " + A.columns + " rows: "+A.rows);

        int t = 0;

        VertexState state[] = new VertexState[(d.rows - 1) * d.rows / 2];//tyle stanów

        for (int i = 0; i < d.rows - 1; i++) {
            for (int j = i + 1; j < d.columns; j++) {
                for (int x = 0; x < state.length; x++) {
                    state[x] = VertexState.White;//na początku białe
                }
                g.put(t, 0, d.get(i, j));
                runDFS(i, j, state, d, V, vertNum);
                for (int ii = 0; ii < krawedzie; ii++) {
                    if (state[ii] == VertexState.Black) {
                        A.put(t, ii, 1);
                    }
                }

                t++;
            }
        }
        System.out.println(g);
        System.out.println("t:" + t);
        return;
    }

    public static boolean isEdge(int u, int v, ArrayList[] V) {
        if (V[u].contains(v)) {
            return true;
        }
        return false;

    }

    public static VertexState runDFS(int i, int j, VertexState[] state, DoubleMatrix d, ArrayList[] V, int vertNum) {
        System.out.println(i);
        state[i] = VertexState.Gray;
        if (!isEdge(i, j, V)) {
            for (int v = 0; v <= vertNum; v++) {
                if (isEdge(i, v, V) && state[v] == VertexState.White) {
                    if (runDFS(v, j, state, d, V, vertNum) == VertexState.Black){
                                    state[i] = VertexState.Black;
                                    return VertexState.Black;}
                }
            }
        } else {
            state[j] = VertexState.Black;
            return VertexState.Black;
        }
        return VertexState.Gray;
    }

    public static double nk(DoubleMatrix A, DoubleMatrix d, DoubleMatrix g, ArrayList[] V, int vertNum) {
        DFS(A, d, g, V, vertNum);
        return 0;
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        int nn = n;
        DoubleMatrix d = DoubleMatrix.zeros(2 * n, 2 * n);
        DoubleMatrix d2 = DoubleMatrix.zeros(n, n);

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                d.put(i, j, s.nextDouble());
                d2.put(i, j, d.get(i, j));
            }
        }
        //d2 = new DoubleMatrix(d.data);
        System.out.println(d);
        System.out.println(d);

        List<Integer> L = new ArrayList<Integer>(2 * n);
        List<Double> R = new ArrayList<Double>(2 * n);
        for (int i = 0; i < 2 * n; i++) {
            L.add(0);
            R.add(0.0);
        }
        //inicjalizacja lisci - jako etykiety kolejne liczby od 0
        for (int i = 0; i < n; i++) {
            L.set(i, i);
        }

        //V - drzewo addytywne, które tworzymy
        ArrayList[] V = new ArrayList[2 * n];
        for (int i = 0; i < V.length; i++) {
            V[i] = new ArrayList<Integer>();
        }

        double suma, rmin, rr;
        int i, j, vertNum = n;

        while (n > 3) {
            //wyznaczanie r dla każdego liścia
            for (int a = 0; a < n; a++) {
                suma = 0;
                for (int b = 0; b < n; b++) {
                    suma = suma + d.get(L.get(a), L.get(b));
                }
                suma = suma / (n - 2);
                R.set(a, suma);
            }
            //wyznaczania sąsiadów na podstawie r
            i = 0;
            j = 1;
            rmin = d.get(L.get(0), L.get(1)) - (R.get(0) + R.get(1));
            for (int a = 0; a < n - 1; a++) {
                for (int b = a + 1; b < n; b++) {
                    rr = d.get(L.get(a), L.get(b)) - (R.get(a) + R.get(b));
                    if (rr < rmin) {
                        rmin = rr;
                        i = a;
                        j = b;
                    }
                }
            }

            //usuniecie ze zbioru lisci i,j oraz dodanie k
            L.set(n, vertNum);
            vertNum++;
            i = L.remove(i);
            j = L.remove(j - 1);
            n = n - 1;

            //uaktualnienie d dla każdego pozostałego liścia
            for (int l = 0; l < n - 1; l++) {
                double value = (d.get(i, L.get(l)) + d.get(j, L.get(l)) - d.get(i, j)) / 2;
                d.put(L.get(n - 1), L.get(l), value);
                d.put(L.get(l), L.get(n - 1), value);
            }

            //dodanie odpowiednich krawędzi do tworzonego drzewa
            V[i].add((vertNum - 1));
            V[j].add((vertNum - 1));
            V[vertNum - 1].add(i);
            V[vertNum - 1].add(j);

            //wyznaczenie odległości między nowym wierzchołkiem oraz i,j
            double value = (d.get(i, j) + d.get(i, L.get(0)) - d.get(j, L.get(0))) / 2;
            d.put(i, vertNum - 1, value);
            d.put(vertNum - 1, i, value);
            d.put(j, vertNum - 1, d.get(i, j) - d.get(i, vertNum - 1));
            d.put(vertNum - 1, j, d.get(i, j) - d.get(i, vertNum - 1));
        }

        //3 elementowe drzewo
        double value;
        value = (d.get(L.get(0), L.get(1)) + d.get(L.get(0), L.get(2)) - d.get(L.get(1), L.get(2))) / 2;
        d.put(L.get(0), vertNum, value);
        d.put(vertNum, L.get(0), value);

        value = (d.get(L.get(0), L.get(1)) + d.get(L.get(1), L.get(2)) - d.get(L.get(0), L.get(2))) / 2;
        d.put(L.get(1), vertNum, value);
        d.put(vertNum, L.get(1), value);

        value = (d.get(L.get(0), L.get(2)) + d.get(L.get(1), L.get(2)) - d.get(L.get(0), L.get(1))) / 2;
        d.put(L.get(2), vertNum, value);
        d.put(vertNum, L.get(2), value);

        V[vertNum].add(L.get(0));
        V[vertNum].add(L.get(1));
        V[vertNum].add(L.get(2));
        V[L.get(0)].add(vertNum);
        V[L.get(1)].add(vertNum);
        V[L.get(2)].add(vertNum);

        //wypisanie wyników
        System.out.println(d);


        //DoubleMatrix w2 = DoubleMatrix.zeros(2*n, 2*n);
        ArrayList w = new ArrayList<Integer>();

        for (int a = 0; a <= vertNum; a++) {
            System.out.print(a);
            System.out.print(" : ");
            for (int b = 0; b < V[a].size(); b++) {
                System.out.print(V[a].get(b));
                System.out.print(" ");

                //w2.put(a,b,Integer.parseInt(V[a].get(b).toString()));
                w.add(V[a].get(b));

            }
            System.out.println("");
        }

        DoubleMatrix A = DoubleMatrix.zeros((nn * (nn - 1)) / 2, vertNum);
        DoubleMatrix g = DoubleMatrix.zeros((nn * (nn - 1)) / 2, 1);
        double blad = nk(A, d2, g, V, vertNum);//wrzucam to do siebie - mkd

        //System.out.println(A);
        
        DoubleMatrix p = (new DoubleMatrix(A.rows,A.columns,A.data)).transpose();
        //System.out.println(p.rows + " " + p.columns);
        DoubleMatrix p2 = (new DoubleMatrix(p.rows,p.columns,p.data)).mmul((new DoubleMatrix(A.rows,A.columns,A.data)));
        
        wypisz(p2);
        
        DoubleMatrix p3 = ownInverse(p2);
        //DoubleMatrix p3 = MatrixFunctions.pow(p2,-1);//odwracanie - tutaj jest błąd
        
        wypisz(p3);
        
        DoubleMatrix pTest = p3.mmul(p2);
        System.out.println("Po wymnozeniu testowych otrzymujemy:");
        wypisz(pTest);
        //wypisz(p4);
        DoubleMatrix p4 = p3.mmul(p);
        DoubleMatrix b = p4.mmul(g);
        
        //DoubleMatrix b = MatrixFunctions.pow(A.transpose().mmul(A), -1).mmul(A.transpose()).mmul(g);
        wypisz(g);
        wypisz(b);
        //System.out.println(g);
        //System.out.println(b);
        //System.out.println("Kwadrat bledu wynosi " + blad);

    }
}
